struct를 선언해 상어의 좌표와 속도, 이동 방향, 크기를 저장.

이후 상어 M마리의 정보를 모두 저장해서 vector<Shark> v에 push_back

이후 낚시왕은 위치 (0, 1) 부터 (0, C) 까지 이동 시작

우선, 배열 상 상어를 놓는 put_shark() 호출
put_shark()
 : 벡터 v의 크기만큼 돌면서 배열 arr[][]에 상어의 크기를 넣어줌
 : int x = v[i].x, y = v[I].y;
 : arr[x][y] = v[i].size;

이후, sum+=get_shark(열 좌표, idx) 호출 // 낚시왕이 잡는 물고기
: get_shark()는 벡터 v의 원소를 모두 확인하며 낚시왕과 동일한 열에 있는 물고기 중 가장 땅과 가까이 있는 (행이 작은) 물고기를 확인하고 v에서 제거 후 해당 물고기의 크기를 return

이후, move_shark() 호출, 여기까지 작성하다가 시간 종료

move_shark()
 : 벡터 v를 탐색하며 해당 상어의 x, y좌표를 방향, 속도에 따라 이동시켜줌. 이동 중 벽을 만나면 change_dir로 방향 전환
이동이 끝나면 갱신된 상어의 정보를 새로운 벡터 tmp에 넣어줌.

——> 여기서,, 이제 같은 좌표에 있는 상어를 잡아먹는 기능을 구현 못함… 애초에 코드를 잘못짠듯.